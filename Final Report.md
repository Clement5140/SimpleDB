##《数据库系统概论》项目报告
作者：计63 陈晟祺 2016010981

###系统整体结构
下图为整个工程各个核心模块的 UML 图，其它的结构可以在本文档中进行浏览，包含类之间的合作图、函数调用关系图等。

![image](../UML.png)

###系统功能（必做）
####系统管理模块

数据库库支持的基本数据类型有：
- 整数（`INT`）
- 字符串（`VARCHAR`）
- 浮点数（`FLOAT`），输出固定两位小数
  
支持的 SQL 语句有（具体格式与大作业要求中一致）：
- `CREATE DATABASE ...;`：创建数据库
- `DROP DATABASE ...;`：删除数据库
- `USE ...;`：切换当前数据库
- `SHOW TABLES;`：列出所有表
- `CREATE TABLE ...;`：创建表
- `DESC ...;`：列出表的信息

####查询解析模块
实现了如下四条增删改查操作语句：

- `INSERT INTO ... VALUES ...;`：插入数据
- `DELETE FROM ... WHERE ...`：删除数据
- `UPDATE ... SET ... WHERE ...`：更新数据
- `SELECT ... FROM ... WHERE ...`：查询符合条件的数据

####索引模块

对指定的列和主键（自动）建立了内存中的B+树索引，在单表和双表连接查询时尽可能使用索引进行遍历，提高运行效率。  
在建立索引后插入的数据才会被索引。不允许删除主键的索引。

- `CREATE INDEX table(column);`：创建索引。
- `DROP INDEX table(column);`：删除索引。

###系统功能（选做）

####`DATE` 日期类型
允许将一列的类型指定为`DATE`，并以`'YYYY-mm-dd'`（如`'1998-01-29'`）的形式进行输入和输出。  
在输入时，将会对日期进行检查，任何非法的日期会被拒绝。支持两个日期之间的比较。支持为日期建立索引。

####聚集查询

支持记录的求和、求最值、平均值、计数等运算，最后输出聚集函数的结果。  
支持的聚集函数有：`MAX, MIN, AVG, SUM, COUNT`，其中`COUNT`可以以`COUNT(*)`的形式调用，但不支持`DISTINCT`参数。  

- `SELECT MAX(col_a), MIN(col_b), COUNT(col_c) FROM ... WHERE ...`

聚集函数只能对列作用，而不能对数学表达式作用。

####复杂表达式计算
查询解析模块可以解析复杂的运算表达式，如：
- `SELECT diameter FROM circles WHERE area=1.00;`：化方为圆  
- `UPDATE person SET age=age+1 WHERE birthday='1926-08-17';`：增加一个人的年龄  

####域完整性约束
域完整性约束可以在建表时规定某一个字段的允许取值集合。

- `CHECK gpa IN(4.0, 3.7, 3.3, ...);`：<del>万恶的GPA</del>

####模糊匹配
支持`SQL`语法中的字符串模糊匹配（`LIKE`运算），使用状态机，将诸如`\%`(百分号), `%`(通配符), `[!a]`(非a), `\[!`(方括号+感叹号)的通配符转换为对应的正则表达式后进行处理。  

- `SELECT rank FROM school WHERE name LIKE '%Tsinghua%';`：查询北京与新竹清华的排名


####多主键约束
允许一张表以多个字段共同作为主键，在插入数据时，若所有字段都相同则认为主键冲突
- `PRIMARY KEY(book_id, website_id)`

####外键约束
允许为表中的列指定外键，若插入的值不在外键指向的列中，则拒绝此次操作  
为了语义上的一致性及实现上的简洁性，创建约束时要求列只能为`INT`类型，并且外键指向的列必须存在索引。
- `FOREIGN KEY (student_id) REFERENCES student(id)`

####三个表以上的连接

对于多表连接，遍历各个表中的记录，产生笛卡尔积，再用`WHERE`的表达式过滤记录。  
此功能用最简单的方式实现 ，由于时间复杂度的限制，只能在规模较小的数据集上工作。

- `SELECT ... FROM t1,t2,t3,... WHERE ...;`

###设计原理

####`SQL`解析

SQL语句解析器是整个数据库的前端，其功能是从标准输入或文件中读取SQL语句，解析得抽象语法树。随后抽象语法树将交由查询处理模块分析语义，并实际执行查询任务。

SQL语句的解析器基于`bison`和`flex`工具生成，`flex`和`bison`将分别根据规则文件产生词法、语法分析器，自动对SQL进行解析，然后对于各个语法元素调用预设的代码。

SQL的词法[sql.l](@ref sql.l)和语法[sql.y](@ref sql.y)文件参考了之前本课程作业的直线，也借鉴了开源项目，支持了课程要求的所有`SQL`语句。同时，扩展实现了对更加复杂的表达式支持，例如在`WHERE`与`UPDATE`中可以对任意多个列和字面量进行数学运算。

在`bison`语法文件中，对于各个语法元素有对应类型的语法树节点，在语法解析过程中，解析器将自下而上的建立整个抽象语法树，并在处理到分号时调用查询处理模块，实际执行一条语句。语法树节点均使用动态内存分配方式，采用指针引用子节点。节点所占用的内存，将在查询处理结束后，递归遍历释放。

`SQL`解析器由C语言编写，而其余数据库部分用C++编写。双方的接口在[Execute.cpp](@ref Execute.cpp)中，`bison`产生的文件最终调用这个类中的函数，这些函数再分别调用[DBMS](@ref DBMS)类中的查询处理函数。

####查询处理

查询处理部分接收来自SQL语句解析器产生的抽象语法树，对语句的语义进行分析，并调用数据库接口执行查询。其实现大部分在[DBMS](@ref DBMS)类中。

对于DDL类语句（如建数据库、建表等），处理较为简单，将语法树中必要的信息提取处理，进行简单的类型翻译（从语法部分的枚举量映射到数据表定义的枚举量）后，直接调用数据表和系统管理模块提供的接口即可。对于建表时的字段约束、主键等附加限制，在检查约束合法后，调用数据表的相关接口添加约束或索引。

DML类语句分为增、删、改、查4种，其中`INSERT`不需要读取表中已有的记录，而其余语句都需要遍历过程，并且还需要根据`WHERE`指定的条件筛选出所需的记录。

`INSERT`语句执行时，从语法树中遍历得到每一条待插入记录，然后调用数据表的接口插入记录。在插入前，将要对数据的类型和有效性（特别地，`DATE`类型在此进行了检查）进行检查，拒绝非法数据插入操作。此外还有对空值和缺省值约束的检查。域完整性约束、主键约束、外键约束的检查是由下层的数据表中的逻辑完成的。

对于删、改、查语句，实现了一个通用的记录遍历函数[iterateRecords](@ref DBMS::iterateRecords)，该接口接受表名（可以有多个，用于连接）、`WHERE`条件及一个回调函数。该函数会按照传入的表名和条件，尽可能使用索引，并对于每一条满足条件的记录通过回调函数返回记录。这样三种指令的实现就变得统一，只要修改回调函数的操作即可。对于`SELECT`语句，除了直接打印出获取到的记录信息（对于不同的类型使用不同的打印方式，对`DATE`类型有特殊的处理）以外，还需要处理聚集函数查询（此处有限制，即聚集与非聚集函数不可混用），此时不直接打印信息，而是进行相应的统计操作，最后输出。

记录遍历函数[iterateRecords](@ref DBMS::iterateRecords)是一个基础的函数，它从表中找到符合过滤条件的记录。在只有一张表的情况下，最简单的实现是，逐条遍历表中的记录，将每条记录中的各个字段的值取出，再计算条件表达式的值，如果为真则返回该条记录。在索引的帮助下，我们可以采用更加高效的处理方式。即利用某一列的索引进行遍历，这样会大大降低时间复杂度。故在查询时首先对于`WHERE`的表达式进行分析，检查所有条件用到的字段，如果某一个字段含有索引，则使用这个字段进行遍历。对于用索引遍历出的结果再用先前的方法完整计算条件表达式，以取得另一些（非索引字段）条件不满足的记录，即得到最终结果。

这个函数还有重载版本，支持多表连接。在朴素的情况下，两表链接实现方式是对某一张表顺序遍历，每遍历到一条记录，就取出其各字段的值缓存一下，并对另一张表进行单表遍历。容易知道，这样处理，只有最后遍历的表可以使用索引，因此表的处理顺序对于性能是有影响的，且可能会浪费其他表索引。因此本函数对两表的情况做了特殊处理，即[iterateTwoTableRecords](@ref DBMS::iterateTwoTableRecords)函数，尽可能地找到某个判断条件左右侧两表都有索引，两侧均使用索引，如此处理速度最快；否则若一侧有，则先对另一侧遍历，在有索引一侧进行索引查找。这样处理大大提高了两表连接情况下的 查询速度。但对于三表及以上的表连接，没有进行优化，只有最后一张表可能利用索引，前面的 表都是顺序遍历，因此速度较慢，且会占用大量内存。

另外，在查询中对条件表达式（`WHERE`中）和数值计算表达式（`UPDATE`中）的求值被封装成了[Expression](@ref Expression)类。它能在抽象语法树的表达式节点上进行各种不同数据类型及运算的求值，同时带有类型兼容检测和简单的类型转换（比较结果成为`bool`，或将`int`自动提升为`float`）等功能。其实现为简单的遍历求值，对带传染性的`NULL`值的有特殊处理。另外，字符串的通配（即`SQL`中的`LIKE`操作符）运算也是该类支持的运算之一，其详细实现是[strlike](@ref strlike)函数，将通配符转换为对应的正则表达式后进行匹配。

####记录管理

记录管理模块主要包括[Database](@ref Database)和[Table](@ref Table)两个类。需要底层页式文件系统，即[BufPageManager](@ref BufPageManager)和[FileManager](@ref FileManager)两个类的支持。

这两个类基于给定的代码修改而成，被实现为单例，方便在程序的任意位置使用。对于上层的[Table](@ref Table)，只暴露[BufPageManager](@ref BufPageManager)，而[FileManager](@ref FileManager)是其的一个成员。对[FileManager](@ref FileManager)的调用仅限于打开和关闭文件，其它对于文件的读写操作都通过[BufPageManager](@ref BufPageManager)代理完成。实现细节未进行修改。

在系统管理模块的数据库实现[Database](@ref Database)类中，支持打开、关闭、删除数据库，当打开数据库时会将对应的表的文件都打开，关闭数据库会回写所有缓存中的页，并在关闭相关文件。数据库的元数据未纯文本。文件名为`dbName.db`，文件中包含表的数量，接下来每一行包括表名与表的永久ID，永久ID在索引模块中会被用到。

表和记录的管理实现在[Table](@ref Table)类中。其中结构体[TableHead](@ref TableHead)中存储了关于表的元数据，含列数、列名，列属性（如是否为主键、是否可为空、是否包含索引等），以及每一列的数据在一条记录中的偏移量。表头中还包括每一列的默认值和约束（包含域完整约束、外键约束），默认值和约束都有可能涉及到不定长的数据，而表头的空间非常有限，因此两者会共享表头中一个数据存储区[dataArr](@ref TableHead::dataArr)，可以在里面存储必要的数据。表头的大小（目前为8184字节）一定小于一个页的大小（8192字节），会被写在每个表文件的首页。

在之后的每个页中会依次存储记录，在页的末尾会有一段空间存储该页中有哪些记录的空间实际是存有数据的。每条记录的格式，如下图

```
有数据：
+---------+---------------+----------+-----+
| notNull | RID(column_0) | column_1 | ... |
+---------+---------------+----------+-----+
没有数据：
+---------+---------------+----------+-----+
| nextFree|                 ...            |
+---------+---------------+----------+-----+
```

当某空间存有实际的记录时，最初的4个字节用于存储每一列是否为空值，之后依次为每一列的值，第0列是自动建立的RID，默认情况下是主键。当该空间是空闲的时，最初的4字节存储下一个空闲空间的地址，第一个空闲空间的地址会被记录在表头中，这样空闲空间就被串成一个链表，这样可以方便的查找和维护空闲位置。当插入数据时，从空闲链表的表头取一个空间用来存储，当删除时，当前的空闲空间会被添加到空闲链表的表头。这样的策略是高效的，因为表头的空间有更大的概率命中缓存。

[Table](@ref Table)类对上层提供的接口通过一条临时记录来实现，上层可以对临时记录的每一列进行修改，这些操作不会做任何错误检查(类型的正确性由上层负责)。当修改结束后，上层可以调用[insertTempRecord](@ref Table::insertTempRecord)方法向表中插入这一条临时记录，在这时，会进行主键冲突、约束、外键、空值等的检查。通过这样的设计，让各种约束的检查在插入之前统一进行，减少了错误。对于修改等的操作，在底层的实现为从表中将当前记录拷贝到临时记录，对临时记录修改和检查后再覆盖原记录。通过这样的机制，能够支持一些同时读写一个字段的语句（如`col=col+1`这样的`UPDATE`操作），也保证了任何操作执行的检查和返回的错误信息是一致的，减少了不必要的检查。

[Table](@ref Table)中支持整数`INT`、浮点数`FLOAT`、字符串`VARCHAR`、日期`DATE`，这些类型在记录中都是定长的，整数、浮点数和日期都是4字节（事实上日期类型存储的也是一个整数，表征其从一个标准时刻起经历的 秒数），而`VARCHAR`的大小在建表时确定，为了字节的对齐和存储终结符`\0`，会额外的保留少量空间。

每张表在 系统中对应的文件名为`dbName.tableName.table`，没有建立新的文件夹来存储。本项目所有数据都以文件的形式存储在当前工作目录下。根据设计的命名策略，这些文件名称不会发生冲突。


####索引模块

索引模块主要由[Index](@ref Index)类实现，也需要[RegisterManager](@ref RegisterManager)类的辅助，以及[Table](@ref Table)类的支持。 索引模块使用了`STX::BTREE_SET`，`STX B+ Tree Template Classes`中的一个类。它提供类似`std::set`的接口，底层使用B+树实现，支持将树存储到磁盘以及从磁盘读入索引。索引模块会在打开数据库时将所有索引全部载入；在关闭数据库时，将索引全部回写。由于该类提供的接口较为高层，索引并没有保存在页式文件系统中。树上每个节点的大小是经过优化的，即使有1,000,000条数据，索引的大小也仅在20MB的数量级，而且索引节点的大小与列的类型无关。

索引的[IndexKey](@ref IndexKey)中包括:

- `permID`，表的永久标记，每个表在创建时会被分配。同一数据库中的表`permID`互不相同，在比较时可以通过[RegisterManager](@ref RegisterManager)来找到对应的表并执行相关操作
- `column`：被索引的列的编号
- `rid`：被索引的记录的编号
- `fastCmp`：一个整数，当两条记录fastCmp不同时可以直接比较大小，否则从表中读取记录并比较
  - 对于`INT`与`DATE`，这个域就是值本身
  - 对于`VARCHAR`，是前四个字符的多项式哈希值
  - 对于`FLOAT`，是将值向整数舍入后得到的值
- `isNull`，该记录的该列是否为空，空值需要被特殊处理

对Key的比较：

- 先比较是否有`isNull`，null小于任何值
- 比较`fastCmp`
- 若`fastCmp`相同且该列不是`INT`或`DATE`，那么从表中获取原始记录进行比较
- 若值确实相同，根据`rid`排序

索引在[Table](@ref Table)类中对上层[DBMS](@ref DBMS)暴露的接口为[lowerBound](@ref Index::lowerBound), [lowerBoundEqual](@ref Index::lowerBoundEqual), [upperBound](@ref Index::upperBound), [next](@ref Index::next), [nextEqual](@ref Index::nextEqual), [reversedNext](@ref Index::reversedNext)等，语义基本与`STL`中的同名函数类似，名称带`equal`的版本需要传入值，在返回时会判断是否值相等，是更强的约束。

####域完整性约束的实现

域完整性约束被保存在表头中，包含列编号、约束的值内容、约束运算符（只用到了判等运算）。本项目只对`IN`约束添加了支持，这种约束可以被转化为若干个`=`操作，彼此为或的关系。在插入记录时，逐个检查约束是否满足，若都不满足，则抛出错误。

####多主键约束的实现

主键约束也保存在表头中，每一列有一位用于表示它是否为主键。如果建表时没有指定主键，则第一列`RID`默认成为主键；如果选择了，则以用户指定为准。主键的每一列都会被建立索引，且不可删除。在插入或修改记录时，若主键不是`RID`，则会进行约束检查；对于带主键的列逐个进行检索，一旦找到一条这些列都相同的记录（且不是被修改的记录本身），则抛出错误。

####外键约束的实现

外键约束同样保存在表头中，每一个约束包含三个字段：列编号、外键所属的表的永久ID、外键所在列编号。在添加约束时，会判断两个列类型是否一致（限制只能是`INT`），所指向的表、列是否存在，如果存在则获取相应信息写入约束中。当插入或修改记录时，对于每一个约束，都会根据约束信息的指向到对应的表的关联列中进行查询（这里要求该列必须有索引，由于外键在另外的表中应当是主键，这在语义上是没有问题的），如果没有查询到对应的值，则抛出错误。

###分工说明
由于原本队友临近期中退课，从头重写项目十分困难。本系统中下列部分是在已有项目或开源代码 基础上进行了修改而得： 
  - 增强的页式文件系统 
  - 表结构的管理与修改
  - SQL解析器（词法、文法文件）
  - 多表连接查询
  
以下部分是由我编写的： 
  - 索引的维护
  - 查询解析模块（含查询优化与索引的使用）
  - 数据库的管理
  - 其他所有的附加功能

###参考资料
- SQLite 代码分析： https://huili.github.io/
- http://blog.csdn.net/qq910894904/article/details/34861173
- http://www.jianshu.com/p/NsWbRv
- https://www.zhihu.com/question/22819578
- https://panthema.net/2007/stx-btree
- https://raw.githubusercontent.com/thinkpad20/sql/master/src/lex/sql.l
- https://raw.githubusercontent.com/thinkpad20/sql/master/src/yacc/sql.y
- 姜承尧《MySQL技术内幕：SQL编程》
- 感谢计32/计研17 张宇翔的帮助
